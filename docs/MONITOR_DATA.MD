# Monitor Data Flow - NASA Hackstronauts

## ğŸ“Š Arquitectura del Sistema de Monitoreo

Este documento explica cÃ³mo funciona el sistema de datos en tiempo real para los monitores de amenazas, trayectorias y sistemas de defensa.

## ğŸ”„ Flujo de Datos

```mermaid
graph TD
    A[mockNEOData.ts] --> B[SimulationContext]
    B --> C[useLiveMetrics Hook]
    C --> D[ThreatAssessmentPanel]
    C --> E[TrajectoryAnalysisPanel]
    C --> F[DefenseSystemsPanel]
    D --> G[Monitor UI]
    E --> G
    F --> G
```

## ğŸ“ Estructura de Archivos

### 1. **Datos Base** (`/src/data/mockNEOData.ts`)
Contiene asteroides reales con datos cientÃ­ficos:
```typescript
export const mockNEOs: NEO[] = [
  {
    neo_id: "2000001",
    name: "Apophis",
    diameter_min_m: 340,
    diameter_max_m: 400,
    velocity_km_s: 12.6,
    is_potentially_hazardous: true,
    impact_energy_mt: 1200.0,
    // ... mÃ¡s datos
  }
];
```

### 2. **Contexto Global** (`/src/contexts/SimulationContext.tsx`)
Maneja el estado global de la simulaciÃ³n:
```typescript
interface SimulationContextType {
  selectedAsteroid: Asteroid | null;
  impactCoordinates: { lat: number; lng: number } | null;
  isSimulationActive: boolean;
  simulationStep: 'selection' | 'impact' | 'simulation' | 'results';
}
```

### 3. **Hook de MÃ©tricas** (`/src/hooks/useLiveMetrics.ts`)
**NÃšCLEO DEL SISTEMA** - Procesa datos y genera mÃ©tricas en tiempo real:

```typescript
interface LiveMetrics {
  // MÃ©tricas de amenaza (para monitores)
  energyMT: number;
  distanceKm: number;
  velocityKmh: number;
  timeToImpact: number;
  
  // MÃ©tricas orbitales
  trackingObjects: number;
  averageAltitude: number;
  currentAltitude: number;
  
  // MÃ©tricas de sistemas
  containmentProtocols: number;
  patternRecognition: number;
  dataMiningActive: boolean;
  modelAccuracy: number;
  processedQueries: number;
}
```

**LÃ³gica de ActualizaciÃ³n:**
- Se actualiza cada 2 segundos cuando `isSimulationActive = true`
- Se actualiza inmediatamente cuando cambia `selectedAsteroid`
- Genera valores simulados basados en datos reales del asteroide

### 4. **Paneles de Monitoreo**

#### A. **ThreatAssessmentPanel** - EvaluaciÃ³n de Amenazas
```typescript
// Calcula mÃ©tricas de amenaza (implementaciÃ³n actual)
const energy = metrics.energyMT;              // MT (Megatons)
const distance = metrics.distanceKm / 1000;   // K KM
const velocity = metrics.velocityKmh / 1000;  // K KM/H

// Determina nivel de amenaza
const threatLevel = energy > 50 ? 'HIGH THREAT'
                 : energy > 20 ? 'MEDIUM THREAT'
                 : 'LOW THREAT';
```

#### B. **TrajectoryAnalysisPanel** - AnÃ¡lisis de Trayectoria
```typescript
// Genera puntos de trayectoria
const trajectoryPoints = Array.from({length: 20}, (_, i) => ({
  x: (i / 19) * 100,
  y: 20 + Math.sin((i / 20) * Math.PI) * 30 + Math.random() * 10,
  color: i < 17 ? '#10b981' : '#ef4444'
}));

// MÃ©tricas de impacto
probability: (metrics.collisionProbability * 100).toFixed(2) + '%'
eta: trajectoryPoints.length * 0.5 + 's'
impact: metrics.impactLocation
```

#### C. **DefenseSystemsPanel** - Sistemas de Defensa
```typescript
// Estado de sistemas basado en mÃ©tricas
const systems = {
  laserArray: metrics.patternRecognition > 95 ? 100 : metrics.patternRecognition,
  missilePods: metrics.containmentProtocols > 15 ? 100 : (metrics.containmentProtocols / 15) * 100,
  shieldGen: metrics.dataMiningActive ? 100 : 0,
  reactorCore: metrics.modelAccuracy > 98 ? 100 : (metrics.modelAccuracy - 95) * 33.33,
  communication: metrics.processedQueries > 5000 ? 100 : (metrics.processedQueries / 5000) * 100
};
```

## ğŸ”§ ImplementaciÃ³n en Nuevo Proyecto

### Notas de integraciÃ³n clave

- Al seleccionar una tarjeta en `src/components/features/neo/NEOList.tsx`, se llama a `setSelectedAsteroid(...)` del `SimulationContext`. Esto dispara `useLiveMetrics()` y actualiza de inmediato los monitores (no es necesario pulsar "Simular Impacto" para que "THREAT ASSESSMENT" cambie).
- La fuente de NEOs proviene de `src/services/neoService.ts`, que intenta la API de NASA con `import.meta.env.VITE_NASA_API_KEY` y usa fallback a `src/data/mockNEOData.ts` si la API falla (por lÃ­mite o clave invÃ¡lida).

### Paso 1: Instalar Dependencias
```bash
npm install react typescript
```

### Paso 2: Crear Estructura de Carpetas
```
src/
â”œâ”€â”€ contexts/
â”‚   â””â”€â”€ SimulationContext.tsx
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useLiveMetrics.ts
â”œâ”€â”€ data/
â”‚   â””â”€â”€ mockNEOData.ts
â”œâ”€â”€ components/
â”‚   â””â”€â”€ monitoring/
â”‚       â”œâ”€â”€ ThreatAssessmentPanel.tsx
â”‚       â”œâ”€â”€ TrajectoryAnalysisPanel.tsx
â”‚       â””â”€â”€ DefenseSystemsPanel.tsx
â””â”€â”€ types/
    â””â”€â”€ api.types.ts
```

### Paso 3: Definir Tipos
```typescript
// types/api.types.ts
export interface NEO {
  neo_id: string;
  name: string;
  diameter_min_m: number;
  diameter_max_m: number;
  velocity_km_s: number;
  is_potentially_hazardous: boolean;
  impact_energy_mt: number;
  // ... mÃ¡s propiedades
}

export interface Asteroid {
  id: string;
  name: string;
  diameter: string;
  velocity: string;
  is_hazardous: boolean;
}
```

### Paso 4: Implementar Contexto
Copiar `SimulationContext.tsx` completo del proyecto actual.

### Paso 5: Implementar Hook de MÃ©tricas
Copiar `useLiveMetrics.ts` completo - es el corazÃ³n del sistema.

### Paso 6: Crear Componentes de Monitoreo
Copiar los 3 paneles de monitoreo y adaptar estilos segÃºn necesidades.

### Paso 7: Integrar en App Principal
```typescript
// App.tsx
import { SimulationProvider } from './contexts/SimulationContext';
import { ThreatAssessmentPanel } from './components/monitoring/ThreatAssessmentPanel';

function App() {
  return (
    <SimulationProvider>
      <div className="monitoring-dashboard">
        <ThreatAssessmentPanel />
        <TrajectoryAnalysisPanel />
        <DefenseSystemsPanel />
      </div>
    </SimulationProvider>
  );
}
```

## ğŸ¯ Puntos Clave para la ImplementaciÃ³n

### âœ… Lo que SÃ funciona:
- **Datos simulados realistas** basados en asteroides reales
- **ActualizaciÃ³n automÃ¡tica** cada 2 segundos
- **Reactividad** a cambios de asteroide seleccionado
- **MÃ©tricas coherentes** entre paneles

### âš ï¸ Lo que hay que adaptar:
- **Estilos CSS** - Usar tu sistema de diseÃ±o
- **FÃ³rmulas de cÃ¡lculo** - Ajustar segÃºn necesidades
- **Intervalos de actualizaciÃ³n** - Cambiar frecuencia si es necesario
- **Tipos de datos** - Adaptar interfaces segÃºn tu API

### ğŸ”„ Flujo de IntegraciÃ³n Recomendado:
1. Copiar tipos y contexto
2. Implementar `useLiveMetrics` 
3. Crear un panel bÃ¡sico de prueba
4. Verificar que los datos fluyen correctamente
5. Implementar los 3 paneles completos
6. Personalizar estilos y mÃ©tricas

## ğŸ“ Notas Importantes

- **El hook `useLiveMetrics` es independiente** - puede usarse en cualquier componente
- **Los datos son simulados** pero basados en informaciÃ³n real de asteroides
- **La actualizaciÃ³n es automÃ¡tica** cuando `isSimulationActive = true`
- **Cada panel consume las mismas mÃ©tricas** pero las interpreta diferente
- **El sistema es escalable** - fÃ¡cil agregar nuevas mÃ©tricas o paneles

## ğŸš€ Extensiones Posibles

- Conectar con API real de NASA
- Agregar mÃ¡s tipos de monitores
- Implementar alertas en tiempo real
- Guardar histÃ³rico de mÃ©tricas
- Agregar configuraciÃ³n de intervalos
- Implementar WebSockets para datos reales

---

**Autor**: Sistema de Monitoreo NASA Hackstronauts  
**Fecha**: 2025-01-05  
**VersiÃ³n**: 1.0
